## 1. Общая концепция

**Цель сервиса** – автоматизировать для заказчика подготовку части тендерной документации, связанной с обоснованием НМЦК через запрос коммерческих предложений (КП):

* поиск и сбор контактов поставщиков;
* подготовка текста письма-запроса КП;
* рассылка запросов;
* отслеживание ответов и извлечение цен;
* расчёт НМЦК на основе предложений.

**Тип сервиса:** веб-SaaS (MVP), одна роль пользователя – «Заказчик».
**Язык интерфейса:** русский.

---

## 2. Роли и права

1. **Пользователь (Заказчик)**

   * Регистрация/вход.
   * Создание и редактирование закупок.
   * Запуск и мониторинг поиска поставщиков.
   * Генерация и редактирование писем.
   * Выбор поставщиков для рассылки.
   * Настройка своего почтового аккаунта.
   * Просмотр переписки и КП.
   * Работа с предложениями, расчёт НМЦК.

2. **Администратор (внутренний, для сервиса)** – в MVP:

   * Просмотр списка пользователей и закупок (через админку/консоль).
   * Мониторинг фоновых задач (скрейпинг, LLM, отправка писем).
     UI-часть для админа можно отложить, достаточно тех. инструментов.

---

## 3. Высокоуровневая архитектура

### 3.1. Основные компоненты

* **Frontend (SPA)**

  * Любой современный фреймворк (React/Vue/Svelte).
  * Авторизация через JWT или session cookie.
  * UI-паттерны как в классических CRM/SaaS: левое меню, таблицы, карточки.

* **Backend API**

  * REST/JSON.
  * Язык: Python
  * Модули:

    * Auth & Users.
    * Purchases & Suppliers.
    * Email accounts & Email client.
    * LLM Orchestrator.
    * Web-scraper Orchestrator.
    * Export (Excel).

* **База данных**

  * Реляционная (PostgreSQL или аналог).

* **Фоновые воркеры**

  * Задачи: скрейпинг с помощью Selenium, обращения к LLM, рассылка писем, обработка входящих писем.
  * Очередь задач: Redis/RabbitMQ/простая internal queue.

* **Интеграции**

  * LLM-провайдер (внешний API).
  * Поиск: Yandex (через обычные HTTP-запросы/Yandex Search страницы).
  * Selenium + headless браузер для парсинга страниц.
  * Почта: SMTP + IMAP для внешних почтовых серверов пользователей.

* **Деплой**
  * docker-compose
  * nginx
---

## 4. Модель данных (основные сущности)

Условно, таблицы/сущности:

1. **User**

   * id
   * email (уникальный)
   * password_hash
   * created_at

2. **Purchase (Закупка)**

   * id
   * user_id (владелец)
   * auto_number (инкремент на пользователя: 1,2,3…)
   * custom_name (опционально)
   * full_name (строка, генерируемая: `"Закупка №{auto_number}" + (" — " + custom_name, если указано)`)
   * terms_text (ТЗ / список ТМЦ, text)
   * status (draft / searching_suppliers / suppliers_found / email_prepared / emails_sent / proposals_received / nmck_calculated)
   * nmck_value (число, опционально)
   * nmck_currency (строка, опционально)
   * created_at, updated_at

3. **Supplier (Поставщик)**

   * id
   * purchase_id
   * company_name (если можно вытащить с сайта, иначе домен)
   * website_url
   * relevance_score (оценка от LLM, 0–1)
   * created_at

4. **SupplierContact**

   * id
   * supplier_id
   * email
   * source_url (страница, где найден email)
   * is_selected_for_request (bool)
   * created_at

5. **EmailAccount (почта пользователя)**

   * id
   * user_id
   * smtp_host, smtp_port, smtp_username, smtp_password_encrypted
   * imap_host, imap_port, imap_username, imap_password_encrypted
   * from_name, from_email (можно сохранять)
   * last_verified_at
   * is_verified (bool)

6. **PurchaseEmailTemplate**

   * id
   * purchase_id
   * subject
   * body (text)
   * last_generated_at
   * last_edited_at

7. **EmailMessage**

   * id
   * purchase_id (для связи)
   * supplier_id (опционально, если можно связать)
   * supplier_contact_id (опционально)
   * direction (outbound/inbound)
   * subject
   * body (text, plain/HTML)
   * sent_at / received_at
   * message_id_external (ID письма у почтового сервера)
   * in_reply_to_message_id_external (цепочка)
   * status (for outbound: queued/sent/error)
   * raw_headers (опционально)

8. **Proposal (Предложение поставщика)**

   * id
   * purchase_id
   * supplier_id
   * email_message_id (из которого извлечено)
   * extracted_price_value (число)
   * extracted_currency (строка)
   * additional_terms (text – краткие условия, если извлечём)
   * is_selected_for_nmck (bool)
   * created_at

9. **LLMTask**

   * id
   * type (search_queries_generation / relevance_check / email_generation / proposal_parsing)
   * input (JSON)
   * output (JSON/text)
   * status (queued/in_progress/done/error)
   * error_message
   * created_at, updated_at

10. **ScrapingTask**

    * id
    * purchase_id
    * status (queued/in_progress/done/error)
    * progress (0–100, условно)
    * result_summary (опционально)
    * created_at, updated_at

---

## 5. Функциональные требования по пунктам

### 5.1. Регистрация и вход (п.1)

**Регистрация**

* Форма:

  * Email (обязательное поле).
  * Пароль (обязательное поле).
* Валидации:

  * Email: формат `something@domain`, без кириллицы (проверка по regexp).
  * Пароль:

    * Минимум, например, 8 символов.
    * Проверить, что все символы – не кириллица (латиница, цифры, спецсимволы допускаются).
  * Проверка на дублирование email (уникальность).
* Почту НЕ нужно подтверждать (нет email-верификации).

**Вход**

* Поля: email, пароль.
* Проверка:

  * Сравнение с password_hash.
  * В случае неверных данных – стандартное сообщение об ошибке.
* После входа – перенаправление на список закупок.

### 5.2. Список закупок и создание закупки (п.2, п.3)

**Страница «Закупки»**

* Табличный/карточный список закупок:

  * Название (full_name).
  * Краткое отображение части ТЗ (обрезанный текст).
  * Статус (с текстом и цветным бейджем).
  * Кол-во найденных поставщиков.
  * Наличие НМЦК (значение/прочерк).
* Фильтры/сортировка (MVP: хотя бы сортировка по дате создания).

**Создание закупки**

* Кнопка «Создать закупку».
* Модалка или отдельная страница:

  * Поле «Название закупки» (опционально).
  * Textarea «ТЗ / список ТМЦ» (обязательное).
* После сохранения:

  * Генерация `auto_number` (следующий для данного пользователя).
  * Генерация `full_name`:

    * `Закупка №{auto_number}`.
    * Если пользователь указал `purchase_name`, то `Закупка №{auto_number} — {purchase_name}`.
* Отображение новой карточки в списке.

**Карточка закупки (страница закупки)**

* Блок с исходными данными:

  * full_name
  * ТЗ / список ТМЦ
  * статус
* Блоки по этапам (визуальный «pipeline»):

  1. Поиск поставщиков
  2. Подготовка письма
  3. Рассылка
  4. Получение предложений
  5. Расчёт НМЦК
* Каждый этап показывает текущий прогресс.

### 5.3. Поиск поставщиков (п.4, п.5)

**Триггер**

* При создании закупки (или сразу после сохранения) автоматически создаётся `ScrapingTask` в статусе `queued`.
* Возможность перезапустить поиск из UI (кнопка «Перезапустить поиск поставщиков») – опционально для MVP.

**Шаг 1: генерация поисковых запросов (LLM)**

* LLMTask type: `search_queries_generation`.
* Вход:

  * Текст ТЗ / список ТМЦ.
* Выход:

  * Список строк – поисковые запросы на русском для Yandex (например, 5–10 запросов).
* Логика:

  * Просим LLM разбить ТЗ на группы товаров/услуг и сформировать релевантные поисковые фразы:
    «оптовый поставщик {категория}», «дистрибьютор {бренд}», «промышленное оборудование {тип}» и т.п.

**Шаг 2: скрейпинг Yandex (Selenium)**

* Для каждого поискового запроса:

  * Открыть страницу результатов поиска Yandex.
  * Собрать ссылки на сайты (например, первые N результатов, N настраиваемо).
* Для каждой ссылки:

  * Открыть сайт (главная и/или несколько типичных страниц: контакты/о компании).
  * С помощью Selenium собрать все email-адреса, найденные на страницах (regexp по `mailto:` и тексту).
  * Сохранить:

    * Supplier (website_url, company_name – если удастся вытащить из `<title>` или блока «О компании»).
    * SupplierContact с email и source_url.
  * Исключать дублирование email-адресов по закупке.

**Шаг 3: проверка релевантности (LLM)**

* Для каждого найденного сайта:

  * LLMTask type: `relevance_check`.
  * Вход:

    * Краткий текст со страницы («о компании» / главный текст).
    * Исходное ТЗ или краткий summary ТЗ.
  * Выход:

    * Оценка релевантности (например, 0–1 или релевантен/не релевантен).
* В базе:

  * Храним `relevance_score`.
* В UI:

  * Можно отображать поставщиков с низким score серым или позволять фильтрацию.

**Прогресс**

* В `ScrapingTask`:

  * `status`: in_progress / done / error.
  * `progress`: условный % по количеству обработанных сайтов/запросов.
* В UI на карточке закупки:

  * Иконка загрузки / статус «Идёт поиск поставщиков…».
  * По завершении – статус меняется, появляется таблица поставщиков.

**Таблица поставщиков**

* Колонки:

  * Компания (название, если есть, иначе домен).
  * Сайт.
  * Email-адрес(а) – можно свернуть в список/под-таблицу или показывать первый + количество.
  * Релевантность (балл/иконка).
  * Чекбокс «Выбрать для рассылки».
* Каждый SupplierContact имеет свой чекбокс (можно сделать групповой чекбокс на поставщика).

### 5.4. Генерация письма с запросом КП (п.6)

**Кнопка «Создать письмо с запросом КП»**

* При нажатии:

  * LLMTask type: `email_generation`.
  * Вход:

    * ТЗ / список ТМЦ.
    * (Опционально) тон и стиль письма: формально-деловой.
  * Выход:

    * Subject письма.
    * Body – текст письма.

**Требования к письму:**

* В тексте обязательно включён чёткий, структурированный список ТМЦ с характеристиками, как в ТЗ:

  * Можно как нумерованный список или таблица (MVP текстом).
* Письмо на русском, оформлено в официально-деловом стиле.

**UI:**

* Открывается форма с:

  * Поле «Тема письма» (input).
  * Textarea «Текст письма».
  * Кнопки:

    * «Сгенерировать ещё раз» (перезаписать текущий текст новым вариантом).
    * «Сохранить» (сохраняем как PurchaseEmailTemplate).
* Письмо всегда можно отредактировать вручную, изменения сохраняются.

### 5.5. Выбор поставщиков и экспорт (п.7, п.8)

**Выбор поставщиков**

* В таблице поставщиков/контактов:

  * Чекбоксы на уровне SupplierContact.
  * Чекбокс «Выбрать всех» (по всей таблице или по странице).
* При переключении чекбокса:

  * Обновляется флаг `is_selected_for_request` у SupplierContact.

**Экспорт в Excel**

* Кнопка «Экспорт выбранных поставщиков в Excel».
* Формируется `.xlsx` файл:

  * Колонки, например:

    * Компания
    * Сайт
    * Email
    * Закупка
    * Дата выгрузки
  * Только выбранные контакты.
* Отдаём файл клиенту в виде скачивания.

### 5.6. Подключение почтового сервера пользователя (п.9)

**Настройки email-аккаунта**

* Раздел «Настройки почты» у пользователя (или в контексте закупки, но лучше глобально).
* Поля:

  * SMTP host, port, username, password.
  * IMAP host, port, username, password.
  * From name.
  * From email (если отличается от username).
* Данные паролей сохраняются в зашифрованном виде (минимальная защита, без паранойи, но не plain text).

**Верификация подключения**

* Кнопка «Проверить подключение»:

  * Backend пробует:

    * SMTP: отправить тестовый `NOOP` или письмо самому пользователю (MVP можно просто `NOOP`/auth).
    * IMAP: залогиниться и сделать `LIST`/`INBOX SELECT`.
  * В случае успеха:

    * `is_verified = true`, `last_verified_at = now`.
  * В случае ошибки:

    * Показываем текст ошибки пользователю.

### 5.7. Рассылка писем и отслеживание ответов (п.10, п.11)

**Рассылка писем**

* На странице закупки:

  * Кнопка «Отправить запрос КП выбранным поставщикам».
* При нажатии:

  * Проверка:

    * Есть ли верифицированный email-аккаунт.
    * Есть ли сохранённый шаблон письма (subject + body).
    * Есть ли хотя бы один выбранный контакт.
  * Формируется очередь EmailMessage (outbound):

    * Для каждого выбранного SupplierContact – создаётся запись `EmailMessage` (direction: outbound, status: `queued`).
* Фоновый воркер:

  * Берёт `queued` письма.
  * Через SMTP отправляет:

    * From: данные из EmailAccount.
    * To: email поставщика.
    * Subject/Body: из шаблона.
  * Заполняет `sent_at`, `message_id_external`, статус `sent` или `error`.

**Отслеживание ответов**

* Фоновый воркер IMAP:

  * Периодически (например, каждые N минут) проверяет входящие письма.
  * Для новых писем:

    * Сохраняет `EmailMessage` (direction: inbound, body, subject, received_at, message_id_external, in_reply_to…).
    * Пытается сопоставить с отправленными:

      * По `In-Reply-To`/`References`, либо по subject/адресам.
      * Ставит `supplier_id`, `purchase_id` если возможно.
* UI:

  * В карточке закупки – вкладка «Переписка»:

    * Список цепочек (поставщик – цепочка писем).
    * Возможность открыть переписку.

**Ведение переписки (п.11)**

* MVP:

  * Система может отправить **один ответ** на входящее письмо (например, уточнение).
  * В UI:

    * В цепочке есть кнопка «Ответить».
    * Форма для ввода текста ответа.
    * После одного ответа по конкретному цепочному письму – блокируем дальнейшие ответы из сервиса, показывая сообщение «Дальнейшая переписка – вручную в вашем почтовом клиенте».
* Отправка ответа:

  * Создаём новый outbound EmailMessage, указываем `In-Reply-To` и `References`, отправляем через SMTP.

### 5.8. Обработка КП, предложения и НМЦК (п.12)

**Извлечение цены из КП**

* При появлении нового входящего письма, связанного с закупкой:

  * Запускаем LLMTask type: `proposal_parsing`.
  * Вход:

    * Subject письма.
    * Текст письма (и вложения, если получится хотя бы текстово).
  * Задача LLM:

    * Выделить:

      * Цену/цены.
      * Валюту.
      * При необходимости – краткие условия (сроки поставки, НДС/без НДС, минимальная партия).
  * Выход:

    * Структура JSON: {price_value, currency, notes...}

* На основе этого:

  * Создаём `Proposal`:

    * purchase_id, supplier_id, email_message_id.
    * extracted_price_value, extracted_currency, additional_terms.

**UI для предложений**

* На странице закупки – вкладка «Предложения»:

  * Таблица:

    * Поставщик.
    * Цена.
    * Валюта.
    * Условия (коротко).
    * Checkbox «Учитывать при расчёте НМЦК» (`is_selected_for_nmck`).
* Пользователь может:

  * Включать/исключать предложения из расчёта.
  * При необходимости – вручную отредактировать цену или валюту (MVP – можно предусмотреть edit-иконку).

**Расчёт НМЦК**

* Кнопка «Рассчитать среднюю цену»:

  * По всем `Proposal` с `is_selected_for_nmck = true`:

    * Проверяем, что валюта одна (иначе показываем сообщение, что нужен ручной пересчёт/фильтрация).
    * Считаем среднее арифметическое цен.
  * Результат:

    * Сохраняем в `Purchase.nmck_value` и `nmck_currency`.
    * Обновляем статус закупки до `nmck_calculated`.
* В UI:

  * Отдельный блок «НМЦК закупки»:

    * Значение.
    * Валюта.
    * Список предложений, участвовавших в расчёте (для прозрачности).

---

## 6. Landing page (п.13)

**Задача:** формальный, но визуально привлекательный лендинг, ведущий к регистрации/входу.

**Содержание:**

* Верхнее меню:

  * Логотип/название сервиса.
  * Кнопки «Войти», «Зарегистрироваться».
* Hero-блок:

  * Короткий заголовок:
    «Автоматизируйте обоснование НМЦК через запрос коммерческих предложений».
  * Подзаголовок 1–2 строки про экономию времени.
  * Кнопка «Начать работу» → регистрация.
* Визуал:

  * Футуристичный, но минималистичный:

    * градиенты, неоновые акценты, сетка/абстрактные формы;
    * много пустого пространства (whitespace);
    * тёмная или светлая тема – но важно современное ощущение.
* Блок 2–3 преимущества:

  * «Автоматический поиск поставщиков и email-контактов».
  * «Генерация писем и рассылка из вашего почтового ящика».
  * «Автоматическое извлечение цен из КП и расчёт НМЦК».
* Футер:

  * Контакты (почта компании).
  * Линки на политику конфиденциальности/оферту (можно stub).

---

## 7. UX-паттерны для консервативных пользователей (п.14)

Чтобы не пугать аудиторию, используем привычные CRM/SaaS-паттерны:

* **Левая боковая навигация:**

  * Пункты: «Закупки», «Настройки почты», «Профиль» (по минимуму).

* **Хедер с user-меню:**

  * Имя/почта пользователя.
  * Кнопка выхода.

* **Табличные представления:**

  * Закупки: таблица со строками.
  * Поставщики: таблица с фильтрами и сортировкой.
  * Предложения: таблица.

* **Карточка объекта:**

  * Шапка с названием и статусом.
  * Вкладки (табами):

    * «Общее» (ТЗ, статус, базовая инфа).
    * «Поставщики».
    * «Письмо».
    * «Переписка».
    * «Предложения / НМЦК».

* **Стандартные контролы:**

  * Кнопки «Сохранить», «Отменить».
  * Чекбоксы, выпадающие списки, модальные окна для редактирования.

* **Состояния:**

  * Пустые списки с подсказкой:
    «Поставщики ещё не найдены. Поиск запустится автоматически.»
  * Понятные сообщения об ошибках.

* **Минимальная «магия»:**

  * Все автоматические действия (поиск поставщиков, парсинг КП) сопровождаются статусами/текстом «что сейчас происходит», чтобы пользователь чувствовал контроль.

---

## 8. Нефункциональные требования (MVP-уровень)

* **Безопасность (минимальная):**

  * HTTPS.
  * Хранение паролей только в виде хэша (bcrypt/argon2).
  * Шифрование полей паролей почтовых аккаунтов.
  * Ограниченное логирование (не логировать пароли/секреты).

* **Производительность:**

  * Нет жёстких требований; допустимы задержки при скрейпинге и LLM.
  * UI должен показывать «в работе»/спиннеры во время долгих операций.

* **Масштабируемость:**

  * Ориентир на небольшое число пользователей в пилоте.
  * Структура с очередями задач, чтобы позже можно было масштабировать воркеры.

* **Логи и мониторинг:**

  * Логирование ошибок backend и воркеров.
  * Возможность смотреть статус задач (через админ-инструменты).

---

## 9. Использование LLM – общие принципы

* Вынести обращения к LLM в отдельный модуль/сервис.
* Для каждого типа задачи – свой промпт-шаблон:

  1. Генерация поисковых запросов по ТЗ.
  2. Проверка релевантности сайта.
  3. Генерация письма-запроса КП.
  4. Извлечение цен из текста письма.
* Хранить input/output LLMTasks в базе (для отладки и последующего улучшения).
* Заложить возможность ручной корректировки того, что сделал LLM (особенно письмо и цены).
